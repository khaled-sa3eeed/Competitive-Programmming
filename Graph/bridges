const int N = 3e5 + 5;
 
vector<pair<int, int>> bridges(vector<vector<int>>& adj)
{
    int n = (int)adj.size() - 1, timer = 0;
 
    vector<pair<int, int>> ret;
    vector<bool> vis(n + 1, false);
    vector<int> tin(n + 1, 1e9), low(n + 1, 1e9);
 
    function<void(int, int)> dfs = [&](int node, int par)
    {
        vis[node] = true;
        low[node] = tin[node] = timer++;
 
        bool skip_par = false;
        for (auto& it : adj[node])
        {
            if (it == par && !skip_par)
            {
                skip_par = true;
                continue;
            }
 
            if (vis[it]) { low[node] = min(low[node], tin[it]); }
            else
            {
                dfs(it, node);
                low[node] = min(low[node], low[it]);
                if (low[it] > tin[node]) { ret.push_back({node, it}); }
            }
        }
    };
 
    for (int i = 1; i <= n; i++)
    {
        if (!vis[i]) { dfs(i, -1); }
    }
    return ret;
}
 
set<pair<int, int>> bri;
vector<int> dist(N), vis(N);
 
void dfs(int node, int dis, vector<vector<int>>& adj)
{
    if (vis[node]) { return; }
    vis[node] = 1;
    dist[node] = dis;
    for (auto& it : adj[node])
    {
        dfs(it, dis + bri.count({node, it}), adj);
    }
}
